/*******************************************************************************
 * Copyright (c) 2011 neXtep Software and contributors.
 * All rights reserved.
 *
 * This file is part of neXtep designer.
 *
 * NeXtep designer is free software: you can redistribute it 
 * and/or modify it under the terms of the GNU General Public 
 * License as published by the Free Software Foundation, either 
 * version 3 of the License, or any later version.
 *
 * NeXtep designer is distributed in the hope that it will be 
 * useful, but WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Contributors:
 *     neXtep Softwares - initial API and implementation
 *******************************************************************************/
package com.nextep.designer.sqlgen.model;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import com.nextep.datadesigner.model.INamedObject;
import com.nextep.datadesigner.sqlgen.model.DatabaseReference;
import com.nextep.datadesigner.sqlgen.model.IDatafileGeneration;
import com.nextep.datadesigner.sqlgen.model.ISQLScript;
import com.nextep.designer.core.model.DBVendor;

/**
 * The result of a generation. A generation may result in several scripts depending on the actions
 * performed. Depending on the drop strategy, a generator may need to drop other objects.<br>
 * An {@link IGenerationResult} interface encapsulates all actions (add, modify, drop) in dedicated
 * scripts which are hashed by {@link DatabaseReference}.<br>
 * Note that generated scripts may be partial. In this case the complete SQL statement will be
 * handled by the encapsulating generator.<br>
 * i.e. Columns generators will generate partial SQL scripts which will be integrated as part of the
 * table generator process in the appropriate ALTER TABLE scripts.<br>
 * <br>
 * Drop scripts <b>MUST NEVER BE PARTIAL</b> since they will depend on complex strategy mechanism.
 * 
 * @author Christophe Fondacci
 */
public interface IGenerationResult extends Comparable<IGenerationResult>, INamedObject {

	/**
	 * @return the scripts which add objects to the database hashed by the database reference of the
	 *         added objects
	 */
	public List<ISQLScript> getAdditions();

	/**
	 * @return the scripts which modify database objects hashed by the database reference of the
	 *         modified objects
	 */
	public List<ISQLScript> getUpdates();

	/**
	 * @return the scripts which drop database objects hashed by the database reference of the
	 *         dropped objects
	 */
	public List<ISQLScript> getDrops();

	/**
	 * Add a script which adds the specified database reference to the database.
	 * 
	 * @param ref database reference of the object added by the script
	 * @param script script which contains SQL statements to ADD the object to the database
	 */
	public void addAdditionScript(DatabaseReference ref, ISQLScript script);

	/**
	 * Add a script which modify the specified database reference within the database. Note that if
	 * the modify strategy of a given database object is to DROP / RECREATE the object, then it is
	 * not an update script and 2 scripts must be registered as addition and drop.
	 * 
	 * @param ref database reference of the object modified by the script
	 * @param script script which contains SQL statements to MODIFY the object to the database.
	 */
	public void addUpdateScript(DatabaseReference ref, ISQLScript script);

	/**
	 * Add a script which drops the specified database reference in the database.<br>
	 * <b>Drop scripts MUST NEVER BE PARTIAL.</b>
	 * 
	 * @param ref database reference of the object dropped by the script
	 * @param script script which contains SQL statement to DROP the object in the database.
	 */
	public void addDropScript(DatabaseReference ref, ISQLScript script);

	/**
	 * @return the preconditions of this generation result. Preconditions are the elements which
	 *         should be generated BEFORE this object if those elements are in the generation set.
	 */
	public Collection<DatabaseReference> getPreconditions();

	/**
	 * Adds a precondition to this generation result. Preconditions are used to order generation
	 * results before the resulting generation script is assembled.
	 * 
	 * @param ref a database reference precondition
	 */
	public void addPrecondition(DatabaseReference ref);

	/**
	 * @return the collection of objects which has been generated by the generation (either add or
	 *         update)
	 */
	public Collection<DatabaseReference> getGeneratedReferences();

	/**
	 * This method integrates the specified child result to this one. All redundancies will be
	 * resolved.
	 * 
	 * @param childResult result to integrate to this one
	 */
	public void integrate(IGenerationResult childResult);

	/**
	 * Builds a SQL Script from the assembly of all contained scripts of this result.
	 * 
	 * @return the generated script
	 */
	public List<ISQLScript> buildScript();

	/**
	 * @return the addedReferences
	 */
	public Map<DatabaseReference, ISQLScript> getAddedReferences();

	/**
	 * @return the updatedReferences
	 */
	public Map<DatabaseReference, ISQLScript> getUpdatedReferences();

	/**
	 * @return the droppedReferences
	 */
	public Map<DatabaseReference, ISQLScript> getDroppedReferences();

	/**
	 * Adds a datafile generation to this result set. Mainly here to support data set generation
	 * "properly".
	 * 
	 * @param ref reference of the database object whose contents are in the specified file
	 *        generation item
	 * @param fileGeneration file generation item
	 */
	public void addDatafileGeneration(DatabaseReference ref, IDatafileGeneration fileGeneration);

	/**
	 * @return the list of all datafiles to generate, sorted by their dependencies.
	 */
	public List<IDatafileGeneration> getDatafilesGenerations();

	/**
	 * @return the loaded references
	 */
	public Map<DatabaseReference, IDatafileGeneration> getLoadedReferences();

	/**
	 * Defines the vendor for which this generation result has been built.<br>
	 * 
	 * @param vendor {@link DBVendor}
	 */
	public void setVendor(DBVendor vendor);

	/**
	 * @return the {@link DBVendor} for which this generation result has been built. Be careful as
	 *         this information may not always be available. For now, vendor are defined only during
	 *         after generating a delivery.
	 */
	public DBVendor getVendor();

}
